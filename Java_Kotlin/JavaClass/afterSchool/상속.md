# 상속



## 상속

### 개요

서로 다른 종류의 객체가 공유하는 메서드가 필요할 때 사용.

다른 클래스임에도 공통된 필드나 공통된 메서드를 사용할 수 있음.

상속을 하는 클래스를 부모 클래스라고 하며, 상속을 받는 클래스는 자식 클래스라고 한다.

부모 클래스는 자식 클래스의 존재를 모르며, 자식 클래스는 부모 클래스의 존재를 안다.

자식 클래스는 부모 클래스의 필드, 메서드의 수보다 많거나 같다.



### 선언

```JAVA
class SuperClass{
  ...
}

class SubClass extends SuperClass{
  ...
}
```

위 코드에서는 SubClass가 SuperClass를 상속받는다.

SubClass는 SuperClass가 가지고 있는 private멤버를 제외한 필드와 메서드를 기본적으로 가지게 된다.

또한, 자식 클래스는 두개 이상의 클래스를 상속받을 수 없다.



### 생성 순서

자식클래스 객체가 생성될 때는 항상 부모클래스의 객체가 먼저 생성되어야 한다.

부모클래스를 생성하기 위해서는 부모클래스의 생성자를 호출해야 한다.

#### 부모클래스 생성자 호출

```java
super()
```

자식클래스의 생성자의 첫 줄에서 호출해야 하며, 없을 경우 컴파일러가 호출된 자식 클래스의 생성자의 인자와 같은 부모 클래스의 생성자를 자동으로 호출한다.



## 오버라이딩

부모클래스의 메서드가 자식 클래스에 적합하다면, 그대로 사용해도 되지만, 자식 클래스에 적합하지 않는다면, 이 메서드를 고쳐 사용할 필요가 있다. 이를 위한 것이 메서드 오버라이딩이다.

#### 조건

+ 부모 클래스의 메서드와 동일한 시그니쳐를 사용해야 한다.
+ 접근 범위를 축소시킬 수 없다.
+ 반환 타입이 같아야 한다.
+ 추가적인 Exception을 표현할 수 없다.
+ private 메서드, 정적 메서드, final 메서드는 오버라이딩할 수 없다.

#### 어노테이션

오버라이드하는 메서드 위에 @Override 어노테이션을 선언해 이 메서드가 부모클래스의 어떤 메서드를 오바라이딩한다는 것을 명시적으로 보여준다. (오버라이딩할 수 없다면 컴파일 에러를 표시한다.)



### 부모 클래스 멤버 접근, super

자식 클래스가 부모 클래스의 메서드를 오버라이딩하면, 부모클래스의 메서드가 대체되는데, 부모클래스의 메서드를 사용해야 할 때에 사용한다.

```java
super.superClassMethod();
```



### 오버로딩? 오버라이딩?

##### 오버로딩

한 클래스 내에서의 메서드 중복

##### 오버라이딩

상속받은 클래스에서 부모 클래스의 메서드를 덮어씌우는 것.

| 요소            | 오버라이딩  | 오버로딩    |
| --------------- | ----------- | ----------- |
| 메서드 이름     | 같음        | 같음        |
| 매개변수        | 같음        | 다름        |
| 반환타입        | 같음        | 달라도 무방 |
| 상속            | 필요        | 필요 없음   |
| 예외 · 접근범위 | 제약 있음   | 제약 없음   |
| 바인딩          | 동적 바인딩 | 정적 바인딩 |



## 패키지



### 개요

파일 시스템의 폴더를 이용해 클래스 파일을 묶어 관리하기 위함.

클래스가 무수히 많기 때문에, 관리하기 편하고 유지보수하기 편리해짐.

클래스 이름이 같더라도, 패키지가 다르면 클래스가 중복되지 않음.



### 패키지 선언

```java
package com.xxx.xxx; // 도메인 역순. 
```



### 사용

다른 패키지에 있는 public 클래스를 사용하려면, 패키지 경로를 컴파일러에게 알려주어야 한다.

```java
packageName.ClassName valueName = new packageName.ClassName();

...

package packageName;

class ClassName{
  
}
```

패키지 경로를 매번 적기 힘들다면, 아래와 같이 import구문을 사용해도 된다.

```java
import packageName.ClassName;

ClassName valueName = new ClassName();
```

아래 코드는 ccc 폴더 하위의 모든 클래스를 import하는 코드이다.

```java
import aaa.bbb.ccc.*;
```



### 접근 지정자

+ public : 다른 모든 클래스에 공개
+ default : 지정하지 않았을 때, 해당 패키지에서만 공개
+ protected : 자식 클래스에게만 공개
+ private : 공개하지 않음.



## final



### final 클래스

더 이상 상속할 수 없는 클래스

​	=> String 클래스도 final 클래스.



### final 메서드

더 이상 오버라이딩할 수 없는 메서드.

final 클래스의 모든 메서드는 final메서드.



## 타입 변환과 다형성

### 다형성?

대입하는 객체의 타입에 따라 메서드를 다르게 동작하도록 구현.



### 자동 타입 변환

자식 클래스는 부모 클래스로 타입을 변환할 수 있음.

자식 클래스는 부모 클래스를 포함하기 때문.

```java
class P{
  
}

class S extends P{
  
}
```

```java
S s = new S();
P p = s; // 자동 타입 변환
```

s 변수로는 S클래스 내부의 멤버에 접근할 수 있지만,

p 변수는 S클래스 객체를 가리킴에도 P 클래스 내부의 멤버에만 접근할 수 있음.

객체를 메서드 인자로 보낼 때 자동 타입 변환을 이용할 수 있다.

```java
void method(P p){} // P 객체와 S 객체 모두 인자로 보낼 수 있다.
```





### 강제 타입 변환

``` java
P p = new P();
S s = (S) p; // 에러 발생.
```

```java
S s1 = new S();
P p = s1;
S s2 = (S) s2; // 부모 타입 변수이지만, S 클래스의 객체이므로 강제 타입 변환을 해도 에러가 발생하지 않는다.
```



### instanceof

타입을 변환했을 때, 변수가 가리키는 객체의 실제 타입을 구별하기 힘들다.

이때 타입을 구별하기 위한 연산자이다.

```java
valueName instanceof ClassName
```

위 코드는 valueName이라는 변수가 ClassName 클래스 혹은 ClassName의 자식 클래스의 객체인지 확인해 true/false를 반환한다.

이 연산자를 이용해 안전하게 하향 타입 변환을 할 수 있다.