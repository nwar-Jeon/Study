# 자바 방과후 1일차



## 3-5 메서드

### 장점

+ 중복 코드를 줄이고 코드를 재사용
+ 코드를 모듈화해 가독성 높임.



### 구조

```java
public static int sum ( int i1 )
```

+ public : 접근 지정자. 선언이 필수는 아님.
+ static : 정적 메서드 선언(없어도 무방)
+ int : 메서드 반환 타입
+ sum : 메서드명 ( 자유로운 네이밍 가능. )
+ ( int i1 ) : 매개변수 목록. 몇개든지 선언 가능.



### 매개변수 값 전달 방식

+ call by reference : 참조 타입을 매개변수로 넘길 때 사용되며, 매개변수로 주소 자체를 넘기는 방식.
+ call by value : 기본 타입을 매개변수로 넘길 때 사용되며, 매개변수로 값 자체를 넘기는 방식.
  + 값 자체를 넘기므로, 넘겨받은 매개변수와 원래의 변수는 다른 개체.



### 메서드 오버로딩

함수의 이름은 같지만, 실행되는 본문을 다르게 하고 싶은 경우에 사용.

**메서드 중복**이라고도 함.



#### 사용방법

```java
public static int max(int n, int m){
  return n > m ? n : m;
}

public static double max(double n, double m){
  return n > m ? n : m;
}

public static int max(int n, int m, int b){
  return max(max(n,m),b);
}

/*public static double max(int n, int m){
  return n > m ? n : m;
}*/    컴파일 에러.
```

+ 매개변수의 타입이 다른 메서드를 만들어 오버로딩.
+ 매개변수의 개수가 다른 메서드를 만들어 오버로딩.

※ 접근 지정자(public 등), 반환형이 다른 것은 코드상에서 구분할 수 없어 오버로딩 할 수 없음.

=> 메서드 시그니쳐를 이용해 오버로딩(매개변수 타입, 개수, 순서)



## 객체 지향

### 개요

##### 현실 세계에서 구체적이거나 추상적인 사물을 의미. 객체가 객체를 포함할 수도 있음.



### 절차지향 vs 객체지향

절차지향

+ 입력 데이터를 받아 처리한 후, 출력 데티어를 생산하는 **논리적 절차**를 사용
+ 명령어의 순서와 흐름에 초점을 맞춤.
+ 수행할 작업이 직관적.
+ 소프트웨어의 규모가 커지며 한계에 부딪힘. (전 과정에서 복잡하게 얽힌 데이터를 사용.)

객체지향

+ 많은 물체의 상호작용으로 표현.
+ 현실 세계를 객체 댄위로 프로그래밍.
+ 필드와 메서드를 하나로 묶어 표현.

### 

### 객체와 클래스

클래스 : 객체를 만들기 위한 틀, 설계도

객체 : 클래스로 인해 **만들어진** 것. 인스턴스라고도 함.

클래스로 객체를 생성하는 과정을 인스턴스화라고 함.



### 중요 개념

1. 캡슐화
   + 관련된 필드와 메서드를 하나의 캡슐처럼 포장헤 외부에서 알 수 없도록 감추는 것. (= 정보은닉)
2. 상속
   + 상위 객체를 상속받은 하위 객체가 상위객체의 메서드와 필드를 사용할 수 있도록 함.
3. 다형성
   + 대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현하는 기술.
   + 실행 도중, 동일한 이름의 다양한 구현체 중에서 하나의 구현체를 선택.



### 클래스 선언

```java
public class Class{
  //필드
  //메서드
  //클래스
}
```

+ public : 접근 지정자. 필수 명시는 아님.
+ class : 클래스 선언 키워드.
+ Class : 클래스 이름. 자유롭게 선언 가능.
+ 필드 : 클래스 내의 변수 선언 가능.
+ 메서드 : 클래스 내의 메서드 선언 가능. 

##### ※public class는 한 파일에 하나만 선언할 수 있으며, 파일명과 일치해야 한다.



### 객체 생성

클래스 선언은 데이터 타입을 만드는 것과 같음. 따라서, 이를 사용하려면 객체를 생성해야 함.

객체 생성은 new 키워드를 사용.

```java
new Class();
```

위와 같이 만들어진 객체를 변수에 대입시켜 여러번 사용 할 수 있으며, 객체 생성 시의 매개변수에 맞는 생성자를 호출한다.

가리키는 변수가 없다면, 가비지가 되어 GC에 의해 사라진다.



### 멤버 접근

#### 클래스 내부

동일 클래스 내부의 필드를 참조하기 때문에, 필드 이름을 그대로 사용

#### 클래스 외부

외부 객체의 멤버를 사용하려는 것이기 때문에, 생성된 객체명을 통해 참조.

```java
name.field
```

+ name : 외부 객체 이름
+ . : 객체 멤버 참조 연산자
+ field : name 객체 안의 필드. (메서드도 접근 가능.)



### 접근자, 설정자

캡슐화를 위해 private로 선언한 필드에 접근하기 위한 public 메서드.

필드의 값을 설정(설정자)하거나, 필드의 값에 접근(접근자)해 값을 가져오기 위함.

```java
class Class{
  private int a;
  public void setA(int a){
    if(a<0) a = 0;
    this.a = a;
  }
  public int getA(){
    return a;
  }
}
```



### 생성자

객체를 생성 할 때, 필드를 초기화해야 할 수 있다. 주로 필드를 초기화하기 위해 사용하며, 객체를 생성할 때 각 객체당 한 번 씩만 실행된다.

#### 선언 방법

```java
public 클래스이름(매개변수 목록){
  생성자 본문
}
```

+ public : 접근 지정자. 주로 public으로 선언하지만, 상황에 따라서 다른 접근 지정자로 선언할 수도 있음.
+ 생성자도 오버로딩할 수 있다.
+ 생성자에서 같은 클래스의 다른 생성자를 호출할 수 있다.
+ 생성자 선언을 하지 않으면, 본문과 매개변수가 없는 생성자(기본생성자)를 자동으로 만들어 호출한다.



### 동일 객체 내부 참조

#### this.

+ 자기 자신의 필드나 메서드를 참조할 때에 사용.

#### this()

+ 자기 자신의 생성자를 사용할 때에 사용. 생성자 내부에서만 사용 가능.



### 메서드 체이닝

여러 메서드를 하나의 실행문에서 연속해 호출.

메서드가 자기 자신을 반환해야 활용할 수 있음.

```java
class Person{
  String age;
  int age;
  public Person setName(String name){
    this.name = name;
    return this;
  }
  public Person setAge(int age){
    this.age = age;
    return this;
  }
  public Person sayHello(){
    System.out.println(name + " " + age);
  }
  public static void main(String[] args){
    new Person().setName("이름").setAge(10).sayHello();
  }
}
```



### 정적 멤버

딱 한 번만 만들어지는 객체의 멤버. 모든 동일 종류 객체가 공유함.

객체를 생성하지 않아도 사용이 가능함.

public static void main(String[] args)도 정적 멤버(정적 메서드)임.

```java
static int field;
static void method(){}
```

static : 정적 멤버 선언 키워드



### 정적 블록

```java
static int staticField;

static{
  int sum = 0;
  for(int i=1; i<=10; i++){ sum += i; }
  staticField = sum;
}
```

정적 메서드 초기화가 복잡할 때, 명령어를 실행한 후 초기화하기 위해 사용.